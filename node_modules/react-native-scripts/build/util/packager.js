'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var cleanUpPackager = function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(projectDir) {
    var result, _ref2, packagerPid;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _promise2.default.race([_xdl.Project.stopAsync(projectDir), new _promise2.default(function (resolve, reject) {
              return setTimeout(resolve, 1000, 'stopFailed');
            })]);

          case 2:
            result = _context.sent;

            if (!(result === 'stopFailed')) {
              _context.next = 15;
              break;
            }

            _context.prev = 4;
            _context.next = 7;
            return _xdl.ProjectSettings.readPackagerInfoAsync(projectDir);

          case 7:
            _ref2 = _context.sent;
            packagerPid = _ref2.packagerPid;

            process.kill(packagerPid);
            _context.next = 15;
            break;

          case 12:
            _context.prev = 12;
            _context.t0 = _context['catch'](4);

            process.exit(1);

          case 15:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[4, 12]]);
  }));

  return function cleanUpPackager(_x) {
    return _ref.apply(this, arguments);
  };
}();

var _xdl = require('xdl');

var _bunyan = require('bunyan');

var _bunyan2 = _interopRequireDefault(_bunyan);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO get babel output that's nice enough to let it take over the console
function clearConsole() {
  process.stdout.write(process.platform === 'win32' ? '\x1Bc' : '\x1B[2J\x1B[3J\x1B[H');
}

function installExitHooks(projectDir) {
  if (process.platform === 'win32') {
    require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    }).on('SIGINT', function () {
      process.emit('SIGINT');
    });
  }

  process.on('SIGINT', function () {
    console.log('\nStopping packager...');
    cleanUpPackager(projectDir).then(function () {
      console.log(_chalk2.default.green('Packager stopped.'));
      process.exit();
    });
  });
}

function run(onReady) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var packagerReady = false;
  var needsClear = false;
  var logBuffer = '';
  var projectDir = process.cwd();
  _xdl.ProjectUtils.attachLoggerStream(projectDir, {
    stream: {
      write: function write(chunk) {
        // don't show the initial packager setup, so that we can display a nice getting started message
        // note: it's possible for the RN packager to log its setup before the express server is done
        // this is a potential race condition but it'll work for now
        if (chunk.msg.indexOf('Loading dependency graph, done.') >= 0) {
          packagerReady = true;
          // TODO clearConsole();
          onReady();
          return;
        }

        var messagePrefix = _chalk2.default.dim(new Date().toLocaleTimeString()) + ':';

        // we don't need to print the entire manifest when loading the app
        if (chunk.msg.indexOf(' with appParams: ') >= 0) {
          if (needsClear) {
            // this is set when we previously encountered an error
            // TODO clearConsole();
          }
          console.log(messagePrefix + ' Loading your app...\n');
          return;
        }

        if (packagerReady) {
          var message = messagePrefix + ' ' + chunk.msg + '\n';
          if (chunk.level <= _bunyan2.default.INFO) {
            console.log(message);
          } else if (chunk.level === _bunyan2.default.WARN) {
            console.log(_chalk2.default.yellow(message));
          } else {
            console.log(_chalk2.default.red(message));

            // if you run into a syntax error then we should clear log output on reload
            needsClear = message.indexOf('SyntaxError') >= 0;
          }
        } else {
          if (chunk.level >= _bunyan2.default.ERROR) {
            console.log(_chalk2.default.yellow('***ERROR STARTING PACKAGER***'));
            console.log(logBuffer);
            console.log(_chalk2.default.red(chunk.msg));
            logBuffer = '';
          } else {
            logBuffer += chunk.msg + '\n';
          }
        }
      }
    },
    type: 'raw'
  });

  installExitHooks(projectDir);
  console.log('Starting packager...');

  _xdl.Project.startAsync(projectDir, options).then(function () {}, function (reason) {
    console.log(_chalk2.default.red('Error starting packager: ' + reason.stack));
    process.exit(1);
  });
}

exports.default = { run: run };
module.exports = exports['default'];
//# sourceMappingURL=packager.js.map
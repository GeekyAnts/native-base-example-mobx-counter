{"version":3,"sources":["packager.js"],"names":["projectDir","race","stopAsync","resolve","reject","setTimeout","result","readPackagerInfoAsync","packagerPid","process","kill","exit","cleanUpPackager","clearConsole","stdout","write","platform","installExitHooks","require","createInterface","input","stdin","output","on","emit","console","log","then","green","run","onReady","options","packagerReady","needsClear","logBuffer","cwd","attachLoggerStream","stream","chunk","msg","indexOf","messagePrefix","dim","Date","toLocaleTimeString","message","level","INFO","WARN","yellow","red","ERROR","type","startAsync","reason","stack"],"mappings":";;;;;;;;;;;;;;;;;;;wEAiCA,iBAA+BA,UAA/B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACuB,kBAAQC,IAAR,CAAa,CAChC,aAAQC,SAAR,CAAkBF,UAAlB,CADgC,EAEhC,sBAAY,UAACG,OAAD,EAAUC,MAAV;AAAA,qBAAqBC,WAAWF,OAAX,EAAoB,IAApB,EAA0B,YAA1B,CAArB;AAAA,aAAZ,CAFgC,CAAb,CADvB;;AAAA;AACQG,kBADR;;AAAA,kBAMMA,WAAW,YANjB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mBASoC,qBAAgBC,qBAAhB,CAAsCP,UAAtC,CATpC;;AAAA;AAAA;AAScQ,uBATd,SAScA,WATd;;AAUMC,oBAAQC,IAAR,CAAaF,WAAb;AAVN;AAAA;;AAAA;AAAA;AAAA;;AAYMC,oBAAQE,IAAR,CAAa,CAAb;;AAZN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeC,e;;;;;AA/Bf;;AAEA;;;;AACA;;;;;;AAEA;AACA,SAASC,YAAT,GAAwB;AACtBJ,UAAQK,MAAR,CAAeC,KAAf,CAAqBN,QAAQO,QAAR,KAAqB,OAArB,GAA+B,OAA/B,GAAyC,sBAA9D;AACD;;AAED,SAASC,gBAAT,CAA0BjB,UAA1B,EAAsC;AACpC,MAAIS,QAAQO,QAAR,KAAqB,OAAzB,EAAkC;AAChCE,YAAQ,UAAR,EACGC,eADH,CACmB;AACfC,aAAOX,QAAQY,KADA;AAEfC,cAAQb,QAAQK;AAFD,KADnB,EAKGS,EALH,CAKM,QALN,EAKgB,YAAM;AAClBd,cAAQe,IAAR,CAAa,QAAb;AACD,KAPH;AAQD;;AAEDf,UAAQc,EAAR,CAAW,QAAX,EAAqB,YAAM;AACzBE,YAAQC,GAAR,CAAY,wBAAZ;AACAd,oBAAgBZ,UAAhB,EAA4B2B,IAA5B,CAAiC,YAAM;AACrCF,cAAQC,GAAR,CAAY,gBAAME,KAAN,CAAY,mBAAZ,CAAZ;AACAnB,cAAQE,IAAR;AACD,KAHD;AAID,GAND;AAOD;;AAmBD,SAASkB,GAAT,CAAaC,OAAb,EAAwD;AAAA,MAAtBC,OAAsB,uEAAJ,EAAI;;AACtD,MAAIC,gBAAgB,KAApB;AACA,MAAIC,aAAa,KAAjB;AACA,MAAIC,YAAY,EAAhB;AACA,MAAMlC,aAAaS,QAAQ0B,GAAR,EAAnB;AACA,oBAAaC,kBAAb,CAAgCpC,UAAhC,EAA4C;AAC1CqC,YAAQ;AACNtB,aAAO,sBAAS;AACd;AACA;AACA;AACA,YAAIuB,MAAMC,GAAN,CAAUC,OAAV,CAAkB,iCAAlB,KAAwD,CAA5D,EAA+D;AAC7DR,0BAAgB,IAAhB;AACA;AACAF;AACA;AACD;;AAED,YAAMW,gBAAgB,gBAAMC,GAAN,CAAU,IAAIC,IAAJ,GAAWC,kBAAX,EAAV,IAA6C,GAAnE;;AAEA;AACA,YAAIN,MAAMC,GAAN,CAAUC,OAAV,CAAkB,mBAAlB,KAA0C,CAA9C,EAAiD;AAC/C,cAAIP,UAAJ,EAAgB;AACd;AACA;AACD;AACDR,kBAAQC,GAAR,CAAee,aAAf;AACA;AACD;;AAED,YAAIT,aAAJ,EAAmB;AACjB,cAAMa,UAAaJ,aAAb,SAA8BH,MAAMC,GAApC,OAAN;AACA,cAAID,MAAMQ,KAAN,IAAe,iBAAOC,IAA1B,EAAgC;AAC9BtB,oBAAQC,GAAR,CAAYmB,OAAZ;AACD,WAFD,MAEO,IAAIP,MAAMQ,KAAN,KAAgB,iBAAOE,IAA3B,EAAiC;AACtCvB,oBAAQC,GAAR,CAAY,gBAAMuB,MAAN,CAAaJ,OAAb,CAAZ;AACD,WAFM,MAEA;AACLpB,oBAAQC,GAAR,CAAY,gBAAMwB,GAAN,CAAUL,OAAV,CAAZ;;AAEA;AACAZ,yBAAaY,QAAQL,OAAR,CAAgB,aAAhB,KAAkC,CAA/C;AACD;AACF,SAZD,MAYO;AACL,cAAIF,MAAMQ,KAAN,IAAe,iBAAOK,KAA1B,EAAiC;AAC/B1B,oBAAQC,GAAR,CAAY,gBAAMuB,MAAN,CAAa,+BAAb,CAAZ;AACAxB,oBAAQC,GAAR,CAAYQ,SAAZ;AACAT,oBAAQC,GAAR,CAAY,gBAAMwB,GAAN,CAAUZ,MAAMC,GAAhB,CAAZ;AACAL,wBAAY,EAAZ;AACD,WALD,MAKO;AACLA,yBAAaI,MAAMC,GAAN,GAAY,IAAzB;AACD;AACF;AACF;AA9CK,KADkC;AAiD1Ca,UAAM;AAjDoC,GAA5C;;AAoDAnC,mBAAiBjB,UAAjB;AACAyB,UAAQC,GAAR,CAAY,sBAAZ;;AAEA,eAAQ2B,UAAR,CAAmBrD,UAAnB,EAA+B+B,OAA/B,EAAwCJ,IAAxC,CACE,YAAM,CAAE,CADV,EAEE,kBAAU;AACRF,YAAQC,GAAR,CAAY,gBAAMwB,GAAN,+BAAsCI,OAAOC,KAA7C,CAAZ;AACA9C,YAAQE,IAAR,CAAa,CAAb;AACD,GALH;AAOD;;kBAEc,EAAEkB,QAAF,E","file":"packager.js","sourcesContent":["// @flow\n\nimport { Project, ProjectSettings, ProjectUtils } from 'xdl';\n\nimport bunyan from 'bunyan';\nimport chalk from 'chalk';\n\n// TODO get babel output that's nice enough to let it take over the console\nfunction clearConsole() {\n  process.stdout.write(process.platform === 'win32' ? '\\x1Bc' : '\\x1B[2J\\x1B[3J\\x1B[H');\n}\n\nfunction installExitHooks(projectDir) {\n  if (process.platform === 'win32') {\n    require('readline')\n      .createInterface({\n        input: process.stdin,\n        output: process.stdout,\n      })\n      .on('SIGINT', () => {\n        process.emit('SIGINT');\n      });\n  }\n\n  process.on('SIGINT', () => {\n    console.log('\\nStopping packager...');\n    cleanUpPackager(projectDir).then(() => {\n      console.log(chalk.green('Packager stopped.'));\n      process.exit();\n    });\n  });\n}\n\nasync function cleanUpPackager(projectDir) {\n  const result = await Promise.race([\n    Project.stopAsync(projectDir),\n    new Promise((resolve, reject) => setTimeout(resolve, 1000, 'stopFailed')),\n  ]);\n\n  if (result === 'stopFailed') {\n    // find RN packager pid, attempt to kill manually\n    try {\n      const { packagerPid } = await ProjectSettings.readPackagerInfoAsync(projectDir);\n      process.kill(packagerPid);\n    } catch (e) {\n      process.exit(1);\n    }\n  }\n}\n\nfunction run(onReady: () => ?any, options: Object = {}) {\n  let packagerReady = false;\n  let needsClear = false;\n  let logBuffer = '';\n  const projectDir = process.cwd();\n  ProjectUtils.attachLoggerStream(projectDir, {\n    stream: {\n      write: chunk => {\n        // don't show the initial packager setup, so that we can display a nice getting started message\n        // note: it's possible for the RN packager to log its setup before the express server is done\n        // this is a potential race condition but it'll work for now\n        if (chunk.msg.indexOf('Loading dependency graph, done.') >= 0) {\n          packagerReady = true;\n          // TODO clearConsole();\n          onReady();\n          return;\n        }\n\n        const messagePrefix = chalk.dim(new Date().toLocaleTimeString()) + ':';\n\n        // we don't need to print the entire manifest when loading the app\n        if (chunk.msg.indexOf(' with appParams: ') >= 0) {\n          if (needsClear) {\n            // this is set when we previously encountered an error\n            // TODO clearConsole();\n          }\n          console.log(`${messagePrefix} Loading your app...\\n`);\n          return;\n        }\n\n        if (packagerReady) {\n          const message = `${messagePrefix} ${chunk.msg}\\n`;\n          if (chunk.level <= bunyan.INFO) {\n            console.log(message);\n          } else if (chunk.level === bunyan.WARN) {\n            console.log(chalk.yellow(message));\n          } else {\n            console.log(chalk.red(message));\n\n            // if you run into a syntax error then we should clear log output on reload\n            needsClear = message.indexOf('SyntaxError') >= 0;\n          }\n        } else {\n          if (chunk.level >= bunyan.ERROR) {\n            console.log(chalk.yellow('***ERROR STARTING PACKAGER***'));\n            console.log(logBuffer);\n            console.log(chalk.red(chunk.msg));\n            logBuffer = '';\n          } else {\n            logBuffer += chunk.msg + '\\n';\n          }\n        }\n      },\n    },\n    type: 'raw',\n  });\n\n  installExitHooks(projectDir);\n  console.log('Starting packager...');\n\n  Project.startAsync(projectDir, options).then(\n    () => {},\n    reason => {\n      console.log(chalk.red(`Error starting packager: ${reason.stack}`));\n      process.exit(1);\n    }\n  );\n}\n\nexport default { run };\n"]}
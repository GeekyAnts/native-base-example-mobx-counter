// Copyright 2015-present 650 Industries. All rights reserved.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareDetachedBuildAsync = exports.detachIOSAsync = exports.detachAsync = undefined;

let detachAsync = exports.detachAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot) {
    let user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error("Internal error -- somehow detach is being run in offline mode.");
    }

    let username = user.username;
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let experienceName = `@${username}/${exp.slug}`;
    let experienceUrl = `exp://exp.host/${experienceName}`;

    // Check to make sure project isn't fully detached already
    let hasIosDirectory = _isDirectory(_path.default.join(projectRoot, 'ios'));
    let hasAndroidDirectory = _isDirectory(_path.default.join(projectRoot, 'android'));

    if (hasIosDirectory && hasAndroidDirectory) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.DIRECTORY_ALREADY_EXISTS, 'Error detaching. `ios` and `android` directories already exist.');
    }

    // Project was already detached on Windows or Linux
    if (!hasIosDirectory && hasAndroidDirectory && process.platform === 'darwin') {
      let response = yield yesnoAsync(`This will add an Xcode project and leave your existing Android project alone. Enter 'yes' to continue:`);
      if (!response) {
        console.log('Exiting...');
        return false;
      }
    }

    if (hasIosDirectory && !hasAndroidDirectory) {
      throw new Error('`ios` directory already exists. Please remove it and try again.');
    }

    console.log('Validating project manifest...');
    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
    if (!exp.name) {
      throw new Error(`${configName} is missing \`name\``);
    }

    if (!exp.android || !exp.android.package) {
      throw new Error(`${configName} is missing android.package field. See https://docs.expo.io/versions/latest/guides/configuration.html#package`);
    }

    if (!exp.sdkVersion) {
      throw new Error(`${configName} is missing \`sdkVersion\``);
    }
    const versions = yield (_Versions || _load_Versions()).versionsAsync();
    let sdkVersionConfig = versions.sdkVersions[exp.sdkVersion];
    if (!sdkVersionConfig || !sdkVersionConfig.androidExpoViewUrl || !sdkVersionConfig.iosExpoViewUrl) {
      if (process.env.EXPO_VIEW_DIR) {
        console.warn(`Detaching is not supported for SDK ${exp.sdkVersion}; ignoring this because you provided EXPO_VIEW_DIR`);
        sdkVersionConfig = {};
      } else {
        throw new Error(`Detaching is not supported for SDK version ${exp.sdkVersion}`);
      }
    }

    if (process.platform !== 'darwin') {
      let response = yield yesnoAsync(`Can't create an iOS project since you are not on macOS. You can rerun this command on macOS in the future to add an iOS project. Enter 'yes' to continue and just create an Android project:`);
      if (!response) {
        console.log('Exiting...');
        return false;
      }
    }

    // Modify exp.json
    exp.isDetached = true;

    if (!exp.detach) {
      exp.detach = {};
    }

    if (!exp.detach.scheme) {
      let detachedUUID = (_nodeUuid || _load_nodeUuid()).default.v4().replace(/-/g, '');
      exp.detach.scheme = `exp${detachedUUID}`;
    }

    let expoDirectory = _path.default.join(projectRoot, '.expo-source');
    (_mkdirp || _load_mkdirp()).default.sync(expoDirectory);

    // iOS
    if (process.platform === 'darwin' && !hasIosDirectory) {
      let iosDirectory = _path.default.join(expoDirectory, 'ios');
      (_rimraf || _load_rimraf()).default.sync(iosDirectory);
      (_mkdirp || _load_mkdirp()).default.sync(iosDirectory);
      yield detachIOSAsync(projectRoot, iosDirectory, exp.sdkVersion, experienceUrl, exp, sdkVersionConfig.iosExpoViewUrl);
      exp.detach.iosExpoViewUrl = sdkVersionConfig.iosExpoViewUrl;
    }

    // Android
    if (!hasAndroidDirectory) {
      let androidDirectory = _path.default.join(expoDirectory, 'android');
      (_rimraf || _load_rimraf()).default.sync(androidDirectory);
      (_mkdirp || _load_mkdirp()).default.sync(androidDirectory);
      yield detachAndroidAsync(projectRoot, androidDirectory, exp.sdkVersion, experienceUrl, exp, sdkVersionConfig.androidExpoViewUrl);
      exp.detach.androidExpoViewUrl = sdkVersionConfig.androidExpoViewUrl;
    }

    console.log('Writing ExpoKit configuration...');
    // Update exp.json/app.json
    // if we're writing to app.json, we need to place the configuration under the expo key
    const nameToWrite = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);
    if (nameToWrite === 'app.json') {
      exp = { expo: exp };
    }
    yield _fs.default.promise.writeFile(_path.default.join(projectRoot, nameToWrite), JSON.stringify(exp, null, 2));

    console.log('Finished detaching your project! Look in the `android` and `ios` directories for the respective native projects.');
    return true;
  });

  return function detachAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

/**
 *  Delete xcodeproj|xcworkspace under searchPath.
 *  Needed because extraneous xcode files will interfere with `react-native link`.
 */
let cleanXCodeProjectsAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (searchPath) {
    let xcodeFilesToDelete = yield (_glob || _load_glob()).default.promise(searchPath + '/**/*.@(xcodeproj|xcworkspace)');
    if (xcodeFilesToDelete) {
      for (let ii = 0; ii < xcodeFilesToDelete.length; ii++) {
        let toRemove = xcodeFilesToDelete[ii];
        if (_fs.default.existsSync(toRemove)) {
          // needed because we may have recursively removed in past iteration
          if (_isDirectory(toRemove)) {
            (_rimraf || _load_rimraf()).default.sync(toRemove);
          } else {
            yield _fs.default.promise.unlink(toRemove);
          }
        }
      }
    }
    return;
  });

  return function cleanXCodeProjectsAsync(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let cleanVersionedReactNativeAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (searchPath) {
    // TODO: make it possible to allow a version for the kernel
    let versionsToDelete = yield (_glob || _load_glob()).default.promise(searchPath + '/ABI*');
    if (versionsToDelete) {
      for (let ii = 0; ii < versionsToDelete.length; ii++) {
        let toRemove = versionsToDelete[ii];
        if (_isDirectory(toRemove)) {
          (_rimraf || _load_rimraf()).default.sync(toRemove);
        }
      }
    }
    return;
  });

  return function cleanVersionedReactNativeAsync(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

let configureDetachedVersionsPlistAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (configFilePath, detachedSDKVersion, kernelSDKVersion) {
    yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, 'EXSDKVersions', function (versionConfig) {
      versionConfig.sdkVersions = [detachedSDKVersion];
      versionConfig.detachedNativeVersions = {
        shell: detachedSDKVersion,
        kernel: kernelSDKVersion
      };
      return versionConfig;
    });
  });

  return function configureDetachedVersionsPlistAsync(_x4, _x5, _x6) {
    return _ref4.apply(this, arguments);
  };
})();

let configureDetachedIOSInfoPlistAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (configFilePath, manifest) {
    let result = yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, 'Info', function (config) {
      // add detached scheme
      if (manifest.isDetached && manifest.detach.scheme) {
        if (!config.CFBundleURLTypes) {
          config.CFBundleURLTypes = [{
            CFBundleURLSchemes: []
          }];
        }
        config.CFBundleURLTypes[0].CFBundleURLSchemes.push(manifest.detach.scheme);
      }
      if (config.UIDeviceFamily) {
        delete config.UIDeviceFamily;
      }
      return config;
    });
    return result;
  });

  return function configureDetachedIOSInfoPlistAsync(_x7, _x8) {
    return _ref5.apply(this, arguments);
  };
})();

let cleanPropertyListBackupsAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (configFilePath) {
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'EXShell', false);
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'Info', false);
    yield (0, (_ExponentTools || _load_ExponentTools()).cleanIOSPropertyListBackupAsync)(configFilePath, 'EXSDKVersions', false);
  });

  return function cleanPropertyListBackupsAsync(_x9) {
    return _ref6.apply(this, arguments);
  };
})();

/**
 *  Create a detached Expo iOS app pointing at the given project.
 */


let detachIOSAsync = exports.detachIOSAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (projectRoot, expoDirectory, sdkVersion, experienceUrl, manifest, expoViewUrl) {
    let {
      iosProjectDirectory,
      projectName
    } = getIosPaths(projectRoot, manifest);

    let tmpExpoDirectory;
    if (process.env.EXPO_VIEW_DIR) {
      // Only for testing
      tmpExpoDirectory = process.env.EXPO_VIEW_DIR;
    } else {
      tmpExpoDirectory = _path.default.join(projectRoot, 'temp-ios-directory');
      (_mkdirp || _load_mkdirp()).default.sync(tmpExpoDirectory);
      console.log('Downloading iOS code...');
      yield (_Api || _load_Api()).default.downloadAsync(expoViewUrl, tmpExpoDirectory, { extract: true });
    }

    console.log('Moving iOS project files...');
    // HEY: if you need other paths into the extracted archive, be sure and include them
    // when the archive is generated in `ios/pipeline.js`
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'ios'), `${expoDirectory}/ios`);
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'cpp'), `${expoDirectory}/cpp`);
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'exponent-view-template', 'ios'), iosProjectDirectory);
    // make sure generated stub exists
    let generatedExpoDir = _path.default.join(expoDirectory, 'ios', 'Exponent', 'Generated');
    (_mkdirp || _load_mkdirp()).default.sync(generatedExpoDir);
    _fs.default.closeSync(_fs.default.openSync(_path.default.join(generatedExpoDir, 'EXKeys.h'), 'w'));

    console.log('Naming iOS project...');
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sed', ['-i', `''`, '--', `s/exponent-view-template/${projectName}/g`, `${iosProjectDirectory}/exponent-view-template.xcodeproj/project.pbxproj`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sed', ['-i', `''`, '--', `s/exponent-view-template/${projectName}/g`, `${iosProjectDirectory}/exponent-view-template.xcworkspace/contents.xcworkspacedata`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('sed', ['-i', `''`, `s/exponent-view-template/${projectName}/g`, `${iosProjectDirectory}/exponent-view-template.xcodeproj/xcshareddata/xcschemes/exponent-view-template.xcscheme`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [`${iosProjectDirectory}/exponent-view-template`, `${iosProjectDirectory}/${projectName}`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [`${iosProjectDirectory}/exponent-view-template.xcodeproj/xcshareddata/xcschemes/exponent-view-template.xcscheme`, `${iosProjectDirectory}/exponent-view-template.xcodeproj/xcshareddata/xcschemes/${projectName}.xcscheme`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [`${iosProjectDirectory}/exponent-view-template.xcodeproj`, `${iosProjectDirectory}/${projectName}.xcodeproj`]);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [`${iosProjectDirectory}/exponent-view-template.xcworkspace`, `${iosProjectDirectory}/${projectName}.xcworkspace`]);

    console.log('Configuring iOS project...');
    let infoPlistPath = `${iosProjectDirectory}/${projectName}/Supporting`;
    let iconPath = `${iosProjectDirectory}/${projectName}/Assets.xcassets/AppIcon.appiconset`;
    yield (0, (_IosShellApp || _load_IosShellApp()).configureStandaloneIOSInfoPlistAsync)(infoPlistPath, manifest);
    let infoPlist = yield configureDetachedIOSInfoPlistAsync(infoPlistPath, manifest);
    yield (0, (_IosShellApp || _load_IosShellApp()).configureStandaloneIOSShellPlistAsync)(infoPlistPath, manifest, experienceUrl);
    // TODO: logic for when kernel sdk version is different from detached sdk version
    yield configureDetachedVersionsPlistAsync(infoPlistPath, sdkVersion, sdkVersion);
    yield (0, (_ExponentTools || _load_ExponentTools()).configureIOSIconsAsync)(manifest, iconPath, projectRoot);
    // we don't pre-cache JS in this case, TODO: think about whether that's correct


    console.log('Configuring iOS dependencies...');
    let podName = sdkVersion === '14.0.0' ? 'ExponentView' : 'ExpoKit';
    yield (0, (_IosPodsTools || _load_IosPodsTools()).renderExponentViewPodspecAsync)(_path.default.join(tmpExpoDirectory, 'template-files', 'ios', `${podName}.podspec`), _path.default.join(expoDirectory, `${podName}.podspec`), { IOS_EXPONENT_CLIENT_VERSION: infoPlist.EXClientVersion });
    yield (0, (_IosPodsTools || _load_IosPodsTools()).renderPodfileAsync)(_path.default.join(tmpExpoDirectory, 'template-files', 'ios', `${podName}-Podfile`), _path.default.join(iosProjectDirectory, 'Podfile'), {
      TARGET_NAME: projectName,
      EXPONENT_ROOT_PATH: _path.default.relative(iosProjectDirectory, expoDirectory),
      REACT_NATIVE_PATH: _path.default.relative(iosProjectDirectory, _path.default.join(projectRoot, 'node_modules', 'react-native'))
    }, sdkVersion);

    console.log('Cleaning up iOS...');
    yield cleanPropertyListBackupsAsync(infoPlistPath);
    yield cleanVersionedReactNativeAsync(_path.default.join(expoDirectory, 'ios', 'versioned-react-native'));
    yield cleanXCodeProjectsAsync(_path.default.join(expoDirectory, 'ios'));

    if (!process.env.EXPO_VIEW_DIR) {
      (_rimraf || _load_rimraf()).default.sync(tmpExpoDirectory);
    }

    // These files cause @providesModule naming collisions
    if (process.platform === 'darwin') {
      let rnFilesToDelete = yield (_glob || _load_glob()).default.promise(_path.default.join(expoDirectory, 'ios') + '/**/*.@(js|json)');
      if (rnFilesToDelete) {
        for (let i = 0; i < rnFilesToDelete.length; i++) {
          yield _fs.default.promise.unlink(rnFilesToDelete[i]);
        }
      }
    }

    const podsInstructions = sdkVersion === '14.0.0' ? '`cd ios && ./pod-install-exponent.sh`' : '`cd ios && pod install`';
    console.log(`iOS detach is complete! To configure iOS native dependencies, make sure you have the Cocoapods gem, then ${podsInstructions}\n`);
    return;
  });

  return function detachIOSAsync(_x10, _x11, _x12, _x13, _x14, _x15) {
    return _ref7.apply(this, arguments);
  };
})();

let regexFileAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (filename, regex, replace) {
    let file = yield _fs.default.promise.readFile(filename);
    let fileString = file.toString();
    yield _fs.default.promise.writeFile(filename, fileString.replace(regex, replace));
  });

  return function regexFileAsync(_x16, _x17, _x18) {
    return _ref8.apply(this, arguments);
  };
})();

let renamePackageAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (directory, originalPkg, destPkg) {
    let originalSplitPackage = originalPkg.split('.');
    let originalDeepDirectory = directory;
    for (let i = 0; i < originalSplitPackage.length; i++) {
      originalDeepDirectory = _path.default.join(originalDeepDirectory, originalSplitPackage[i]);
    }

    // copy files into temp directory
    let tmpDirectory = _path.default.join(directory, 'tmp-exponent-directory');
    (_mkdirp || _load_mkdirp()).default.sync(tmpDirectory);
    yield (_Utils || _load_Utils()).ncpAsync(originalDeepDirectory, tmpDirectory);

    // delete old package
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(directory, originalSplitPackage[0]));

    // make new package
    let newSplitPackage = destPkg.split('.');
    let newDeepDirectory = directory;
    for (let i = 0; i < newSplitPackage.length; i++) {
      newDeepDirectory = _path.default.join(newDeepDirectory, newSplitPackage[i]);
      (_mkdirp || _load_mkdirp()).default.sync(newDeepDirectory);
    }

    // copy from temp to new package
    yield (_Utils || _load_Utils()).ncpAsync(tmpDirectory, newDeepDirectory);

    // delete temp
    (_rimraf || _load_rimraf()).default.sync(tmpDirectory);
  });

  return function renamePackageAsync(_x19, _x20, _x21) {
    return _ref9.apply(this, arguments);
  };
})();

let detachAndroidAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot, expoDirectory, sdkVersion, experienceUrl, manifest, expoViewUrl) {
    let tmpExpoDirectory;
    if (process.env.EXPO_VIEW_DIR) {
      // Only for testing
      tmpExpoDirectory = process.env.EXPO_VIEW_DIR;
    } else {
      tmpExpoDirectory = _path.default.join(projectRoot, 'temp-android-directory');
      (_mkdirp || _load_mkdirp()).default.sync(tmpExpoDirectory);
      console.log('Downloading Android code...');
      yield (_Api || _load_Api()).default.downloadAsync(expoViewUrl, tmpExpoDirectory, { extract: true });
    }

    let androidProjectDirectory = _path.default.join(projectRoot, 'android');

    console.log('Moving Android project files...');

    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'android', 'maven'), _path.default.join(expoDirectory, 'maven'));
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'android', 'detach-scripts'), _path.default.join(expoDirectory, 'detach-scripts'));
    yield (_Utils || _load_Utils()).ncpAsync(_path.default.join(tmpExpoDirectory, 'exponent-view-template', 'android'), androidProjectDirectory);
    if (process.env.EXPO_VIEW_DIR) {
      (_rimraf || _load_rimraf()).default.sync(_path.default.join(androidProjectDirectory, 'build'));
      (_rimraf || _load_rimraf()).default.sync(_path.default.join(androidProjectDirectory, 'app', 'build'));
    }

    // Fix up app/build.gradle
    console.log('Configuring Android project...');
    let appBuildGradle = _path.default.join(androidProjectDirectory, 'app', 'build.gradle');
    yield regexFileAsync(appBuildGradle, /\/\* UNCOMMENT WHEN DISTRIBUTING/g, '');
    yield regexFileAsync(appBuildGradle, /END UNCOMMENT WHEN DISTRIBUTING \*\//g, '');
    yield regexFileAsync(appBuildGradle, `compile project(':expoview')`, '');

    // Fix AndroidManifest
    let androidManifest = _path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'AndroidManifest.xml');
    yield regexFileAsync(androidManifest, 'PLACEHOLDER_DETACH_SCHEME', manifest.detach.scheme);

    // Fix MainActivity
    let mainActivity = _path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'java', 'detach', 'app', 'template', 'pkg', 'name', 'MainActivity.java');
    yield regexFileAsync(mainActivity, 'TEMPLATE_INITIAL_URL', experienceUrl);

    // Fix package name
    let packageName = manifest.android.package;
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'java'), ANDROID_TEMPLATE_PKG, packageName);
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'test', 'java'), ANDROID_TEMPLATE_PKG, packageName);
    yield renamePackageAsync(_path.default.join(androidProjectDirectory, 'app', 'src', 'androidTest', 'java'), ANDROID_TEMPLATE_PKG, packageName);

    let packageNameMatches = yield (_glob || _load_glob()).default.promise(androidProjectDirectory + '/**/*.@(java|gradle|xml)');
    if (packageNameMatches) {
      let oldPkgRegex = new RegExp(`${ANDROID_TEMPLATE_PKG.replace(/\./g, '\\\.')}`, 'g');
      for (let i = 0; i < packageNameMatches.length; i++) {
        yield regexFileAsync(packageNameMatches[i], oldPkgRegex, packageName);
      }
    }

    // Fix app name
    console.log('Naming Android project...');
    let appName = manifest.name;
    yield regexFileAsync(_path.default.resolve(androidProjectDirectory, 'app', 'src', 'main', 'res', 'values', 'strings.xml'), ANDROID_TEMPLATE_NAME, appName);

    // Fix image
    let icon = manifest.icon;
    if (icon) {
      let iconMatches = yield (_glob || _load_glob()).default.promise(_path.default.join(androidProjectDirectory, 'app', 'src', 'main', 'res') + '/**/ic_launcher.png');
      if (iconMatches) {
        for (let i = 0; i < iconMatches.length; i++) {
          yield _fs.default.promise.unlink(iconMatches[i]);
          // TODO: make more efficient
          yield (0, (_ExponentTools || _load_ExponentTools()).saveIconToPathAsync)(projectRoot, icon, iconMatches[i]);
        }
      }
    }

    // Clean up
    console.log('Cleaning up Android...');
    if (!process.env.EXPO_VIEW_DIR) {
      (_rimraf || _load_rimraf()).default.sync(tmpExpoDirectory);
    }
    console.log('Android detach is complete!\n');
  });

  return function detachAndroidAsync(_x22, _x23, _x24, _x25, _x26, _x27) {
    return _ref10.apply(this, arguments);
  };
})();

let prepareDetachedBuildAsync = exports.prepareDetachedBuildAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectDir, args) {
    let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectDir);

    if (args.platform === 'ios') {
      let {
        iosProjectDirectory,
        projectName
      } = getIosPaths(projectDir, exp);

      console.log(`Preparing iOS build at ${iosProjectDirectory}...`);
      // These files cause @providesModule naming collisions
      // but are not available until after `pod install` has run.
      let podsDirectory = _path.default.join(iosProjectDirectory, 'Pods');
      if (!_isDirectory(podsDirectory)) {
        throw new Error(`Can't find directory ${podsDirectory}, make sure you've run pod install.`);
      }
      let rnPodDirectory = _path.default.join(podsDirectory, 'React');
      if (_isDirectory(rnPodDirectory)) {
        let rnFilesToDelete = yield (_glob || _load_glob()).default.promise(rnPodDirectory + '/**/*.@(js|json)');
        if (rnFilesToDelete) {
          for (let i = 0; i < rnFilesToDelete.length; i++) {
            yield _fs.default.promise.unlink(rnFilesToDelete[i]);
          }
        }
      }
      // insert expo development url into iOS config
      if (!args.skipXcodeConfig) {
        let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);
        let configFilePath = _path.default.join(iosProjectDirectory, projectName, 'Supporting');
        yield (0, (_ExponentTools || _load_ExponentTools()).modifyIOSPropertyListAsync)(configFilePath, 'EXShell', function (shellConfig) {
          shellConfig.developmentUrl = devUrl;
          return shellConfig;
        });
      }
    } else {
      let androidProjectDirectory = _path.default.join(projectDir, 'android');
      let expoBuildConstantsMatches = yield (_glob || _load_glob()).default.promise(androidProjectDirectory + '/**/ExponentBuildConstants.java');
      if (expoBuildConstantsMatches && expoBuildConstantsMatches.length) {
        let expoBuildConstants = expoBuildConstantsMatches[0];
        let devUrl = yield (_UrlUtils || _load_UrlUtils()).constructManifestUrlAsync(projectDir);
        yield regexFileAsync(expoBuildConstants, /DEVELOPMENT_URL \= \"[^\"]*\"\;/, `DEVELOPMENT_URL = "${devUrl}";`);
      }
    }
  });

  return function prepareDetachedBuildAsync(_x28, _x29) {
    return _ref11.apply(this, arguments);
  };
})();

require('instapromise');

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _fs = _interopRequireDefault(require('fs'));

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _glob;

function _load_glob() {
  return _glob = _interopRequireDefault(require('glob'));
}

var _nodeUuid;

function _load_nodeUuid() {
  return _nodeUuid = _interopRequireDefault(require('node-uuid'));
}

var _yesno;

function _load_yesno() {
  return _yesno = _interopRequireDefault(require('yesno'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosShellApp;

function _load_IosShellApp() {
  return _IosShellApp = require('./IosShellApp');
}

var _IosPodsTools;

function _load_IosPodsTools() {
  return _IosPodsTools = require('./IosPodsTools.js');
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('../ErrorCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('../project/ProjectUtils'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('../User'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('../XDLError'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('../UrlUtils'));
}

var _Utils;

function _load_Utils() {
  return _Utils = _interopRequireWildcard(require('../Utils'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const ANDROID_TEMPLATE_PKG = 'detach.app.template.pkg.name';
const ANDROID_TEMPLATE_COMPANY = 'detach.app.template.company.domain';
const ANDROID_TEMPLATE_NAME = 'DetachAppTemplate';

function _isDirectory(dir) {
  try {
    if (_fs.default.statSync(dir).isDirectory()) {
      return true;
    }

    return false;
  } catch (e) {
    return false;
  }
}

function yesnoAsync(question) {
  return new Promise(resolve => {
    (_yesno || _load_yesno()).default.ask(question, null, ok => {
      resolve(ok);
    });
  });
}

function getIosPaths(projectRoot, manifest) {
  let iosProjectDirectory = _path.default.join(projectRoot, 'ios');
  let projectNameLabel = manifest.name;
  let projectName = projectNameLabel.replace(/[^a-z0-9_\-]/gi, '-').toLowerCase();
  return {
    iosProjectDirectory,
    projectName
  };
}
//# sourceMappingURL=../__sourcemaps__/detach/Detach.js.map

{"version":3,"sources":["__tests__/tools/FsCache-test.js"],"names":["jest","mock","fsp","require","path","pathExists","describe","it","async","dateCacher","Date","await","clearAsync","e","date1","getAsync","expect","toEqual","setTimeout","then","d","not","expected","JSON","parse","readFile","join","__dirname","failCacher","Error","found"],"mappings":";;;;AAMA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;;;AAPAA,KAAKC,IAALD;;AAEA,MAAME,MAAMC,OAAND,SAAN;AACA,MAAME,OAAOD,OAAPC,QAAN;AACA,MAAMC,aAAaF,OAAbE,eAAN;;AAKAC,SAAS,QAATA,EAAmB,MAAM;AACvBC,KAAG,gCAAHA,oBAAqCC,aAAY;AAC/C,UAAMC,aAA2B,2DAC/BD,aAAY;AAAE,aAAO,IAAIE,IAAJ,EAAP;AAAoB,KADH,GAE/B,UAF+B,EAG/B,IAH+B,CAAjC;;AAMA,QAAI;AACFC,YAAMF,WAAWG,UAAXH,EAANE;AACF,KAFA,CAEE,OAAOE,CAAP,EAAU;AACV;AACF;;AAEA,UAAMC,QAAQ,IAAIJ,IAAJ,EAASC,MAAMF,WAAWM,QAAXN,EAAf,EAAd;;AAEA;AACAO,WAAOF,KAAPE,EAAcC,OAAdD,CAAsB,IAAIN,IAAJ,EAASC,MAAMF,WAAWM,QAAXN,EAAf,EAAtBO;;AAEA;AACAE,eAAW,YAAM;AACfT,iBAAWM,QAAXN,GAAsBU,IAAtBV,CAA2B,UAACW,CAAD,EAAO;AAChCJ,eAAOF,KAAPE,EAAcK,GAAdL,CAAkBC,OAAlBD,CAA0B,IAAIN,IAAJ,CAASU,CAAT,CAA1BJ;AACD,OAFDP;AAGD,KAJDS,EAIG,IAJHA;AAKD,GAxBDX;;AA0BAA,KAAG,6BAAHA,oBAAkCC,aAAY;AAC5C,UAAMc,WAAWC,KAAKC,KAALD,EAAWZ,MAAMT,IAAIuB,QAAJvB,CAAaE,KAAKsB,IAALtB,CAAUuB,SAAVvB,EAAqB,uBAArBA,CAAbF,CAAjBqB,EAAjB;;AAEA,UAAMK,aAAa,yCACjB,YAAM;AAAE,YAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AAA6C,KADpC,EAEjB,WAFiB,EAGjB,IAHiB,EAIjBzB,KAAKsB,IAALtB,CAAUuB,SAAVvB,EAAqB,uBAArBA,CAJiB,CAAnB;;AAOA;AACA,QAAI;AACFO,YAAMiB,WAAWhB,UAAXgB,EAANjB;AACF,KAFA,CAEE,OAAOE,CAAP,EAAU;AACV;AACF;;AAEA,UAAMiB,QAAQnB,MAAMiB,WAAWb,QAAXa,EAApB;;AAEAZ,WAAOc,KAAPd,EAAcC,OAAdD,CAAsBM,QAAtBN;AACD,GApBDT;AAqBD,CAhDDD","file":"../../../__tests__/tools/FsCache-test.js","sourcesContent":["jest.mock('analytics-node');\n\nconst fsp = require('mz/fs');\nconst path = require('path');\nconst pathExists = require('path-exists');\n\nimport { Cacher, getCacheDir } from '../../tools/FsCache';\nimport Config from '../../Config';\n\ndescribe('Cacher', () => {\n  it('works without a bootstrap file', async () => {\n    const dateCacher: Cacher<Date> = new Cacher(\n      async () => { return new Date(); },\n      'dateslol',\n      1000,\n    );\n\n    try {\n      await dateCacher.clearAsync();\n    } catch (e) {\n      // this is ok\n    }\n\n    const date1 = new Date(await dateCacher.getAsync());\n\n    // should be well within the TTL, should be identical value\n    expect(date1).toEqual(new Date(await dateCacher.getAsync()));\n\n    // should be outside of the TTL -- just making sure that sufficient delay will change the value\n    setTimeout(() => {\n      dateCacher.getAsync().then((d) => {\n        expect(date1).not.toEqual(new Date(d));\n      });\n    }, 3000);\n  });\n\n  it('works with a bootstrap file', async () => {\n    const expected = JSON.parse(await fsp.readFile(path.join(__dirname, '../../../package.json')));\n\n    const failCacher = new Cacher(\n      () => { throw new Error('lol this never succeeds'); },\n      'bootstrap',\n      1000,\n      path.join(__dirname, '../../../package.json')\n    );\n\n    // since we don't mock the fs here (.cache is transient), need to make sure it's empty\n    try {\n      await failCacher.clearAsync();\n    } catch (e) {\n      // noop\n    }\n\n    const found = await failCacher.getAsync();\n\n    expect(found).toEqual(expected);\n  });\n});\n"],"sourceRoot":"/xdl/src"}